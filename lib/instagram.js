'use strict'
const RedisClient = require('./redisClient')
const images = require('./images')
const crawl = require('./crawling')

var normalizeError = function (err) {
  return {
    status: err.response.status || 500,
    statusText: err.response.statusText || 'Unknown'
  }
}

const TYPE = {
  TAG: 'tag',
  USER: 'user'
}

// order is important
const urlRules = {
  tag: {
    rule: /((https?):\/\/)?(www\.)?instagram.com\/explore\/tags\/([\w_]+)/mi
  },
  user: {
    rule: /((https?):\/\/)?(www\.)?instagram\.com\/([\w._]+)\/?/mi
  }
}

var typeToFunc = function (type) {
  var func = null
  if (type == TYPE.TAG) {
    func = 'searchByTags'
  } else if (type == TYPE.USER) {
    func = 'searchByUser'
  }
  return func
}

var Instagram = function (opts) {
  var self = this

  this._config = {
    cacheTime: 60 * 30,
    aheadTime: 5 * 30,
    force: false,
    enableFirstTime: false
  }

  // redis default config
  this._redisConfig = {}

  this._redisClient = null

  if (opts.config) {
    const configOpt = ['cacheTime', 'force', 'enableFirstTime', 'aheadTime']
    for (let key of configOpt) {
      if (opts.config[key] !== undefined) {
        this._config[key] = opts.config[key]
      }
    }
  }

  this._redisConfig = opts.redis
  this._redisClient = new RedisClient(this._redisConfig, function () {
    self._redisClient.setLoadState(false, function () {
      self.loadQueue()
    })
  })
}

/**
 * @param {string} [tag] tag name
 * @param {Function} callback
 */
Instagram.prototype.searchByTags = function (tag, cb) {
  crawl.tag(tag).then(function (result) {
    cb(null, result)
  })
  .catch(function (err) {
    cb(normalizeError(err))
  })
}

/**
 * @param {string} [user] user name
 * @param {Function} callback
 */
Instagram.prototype.searchByUser = function (user, cb) {
  crawl.user(user).then(function (result) {
    cb(null, result)
  })
  .catch(function (err) {
    cb(normalizeError(err))
  })
}

/**
 * @param {string} [tag] tag name
 * @param {Function} callback
 */
Instagram.prototype.getMediaByTag = function (tag, cb) {
  var self = this
  var type = TYPE.TAG
  var matchs = tag.match(urlRules[type].rule)
  if (matchs) {
    tag = matchs[4]
  }

  self.getMedia(type, tag, cb)
}

/**
 * @param {string} [user] or [url] user name or url
 * @param {Function} callback
 */
Instagram.prototype.getMediaByUser = function (user, cb) {
  var self = this
  var type = TYPE.USER

  var matchs = user.match(urlRules[type].rule)
  if (matchs) {
    user = matchs[4]
  }
  self.getMedia(type, user, cb)
}

/**
 * @param {string} [url] url
 * @param {Function} callback
 */
Instagram.prototype.getMediaByUrl = function (url, cb) {
  var self = this
  var keys = Object.keys(urlRules)
  var type, value
  for (let key of keys) {
    value = url.match(urlRules[key].rule)
    if (value !== null) {
      type = key
      value = value[4]
      break
    }
  }
  self.getMedia(type, value, cb)
}

Instagram.prototype.getMedia = function (type, q, cb) {
  var self = this
  self._redisClient.getMedia(type, q, function (err, result, exist) {
    if (err) {
      return cb(err)
    }
    if (exist || !self._config.enableFirstTime) {
      result = new images(result)
      cb(err, result)
    } else {
      var func = typeToFunc(type)

      if (!func) {
        return cb()
      }

      self[func](q, function (err, result) {
        result = new images(result)
        cb(err, result)
      })
    }
  })

  self.insertQueue(type, q)
}

Instagram.prototype.updateMedia = function (type, q, cb) {
  var self = this
  self._redisClient.updateMedia({
    type: type,
    q: q,
    cacheTime: self._config.cacheTime,
    aheadTime: self._config.aheadTime,
    checkOnly: false
  }, function (needUpdate) {
    if (self._config.force || needUpdate) {
      var func = typeToFunc(type)

      if (!func) {
        return cb()
      }

      self[func](q, function (err, list) {
        if (err) {
          return cb(err)
        }
        self._redisClient.setMedia(type, q, list, self._config.cacheTime, cb)
      })
    } else {
      cb()
    }
  })
}

Instagram.prototype.loadQueue = function (cb) {
  var self = this
  self._redisClient.getLoadState(function (err, loading) {
    if (loading) {
      cb && cb()
    } else {
      self._redisClient.setLoadState(true, function () {
        self.loadQueueTask()
      })
    }
  })
}

Instagram.prototype.loadQueueTask = function () {
  var self = this
  self._redisClient.popQueue(function (type, q) {
    if (q) {
      self.updateMedia(type, q, function () {
        self.loadQueueTask()
      })
    } else {
      self._redisClient.setLoadState(false)
    }
  })
}

Instagram.prototype.insertQueue = function (type, q, cb) {
  var self = this
  self._redisClient.updateMedia({
    q: q,
    cacheTime: self._config.cacheTime,
    aheadTime: self._config.aheadTime,
    type: type,
    checkOnly: true
  }, function (needUpdate) {
    if (needUpdate) {
      self._redisClient.pushQueue(type, q, function () {
        self.loadQueue()
      })
    }

    cb && cb()
  })
}

module.exports = Instagram
